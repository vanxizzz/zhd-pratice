

限定符（量词）
    匹配
    **前边一个字符** 字符包含普通字符和**元字符**（即用\转义后有其他作用，所以限定符是元字符是子集，因为限定符用\转义后就没有了之前的作用了）
    或
    **()内部的子串**
    或
    **[]字符集合**
    的次数


限定符出现的地方：一个字符后边，()后边，[]后边
* === {0,} 匹配次数>=0

+ === {1,} 匹配次数>=1

? === {0,1} 匹配次数0次或1次

{n} 精准匹配n次

{n,} （有逗号）匹配>=n

{n,m}      n<= 匹配次数 <=m 
**例子**
```js
1. 匹配前边一个字符，注意是一个！！
var str = "abccccc";
var reg = /abc+/;  
str.match(reg)// ["abccccc"]

2. ()内部的子串
var str = "开始abcabc";
var reg = /开始(abc)+/
str.match(reg)//["开始abcabc"]

var str = "a哈嘿嘻";
var reg = /a(哈|嘿)+/


3. []的字符集合
var str = "ab@@bc";
var reg = /a[b@]+bc/
分成3部分：a  [b@]+   bc
所以肯定前边有a，后边有bc，中间有b或@1到多次
所以str.match(reg);//["ab@@bc"]
```



**限定符默认是贪婪匹配模式**
什么叫贪婪匹配
就是：在限定符的范围内，越多越好
比如 a{2,10}可以匹配aa，aaa，aaaa，aaaaa很贪婪

非贪婪匹配
其实就是 a{2,10}变成非贪婪模式：a{2}
```js
1. 
var str = "abccccc";
var reg = /abc+/
str.match(reg)// ["abccccc"]
2. 

```


变成非贪婪匹配模式：**限定符后边** 出现 **问号?**
```js
/abc+?/ => +是限定符，表示c{1,}，但是限定符后边加了？变成非贪婪匹配，所以整个正则表达式其实变成：/abc{1}/
/abc*?/ => *是限定符，表示c{0,}，但是限定符后边加了？变成非贪婪匹配，所以整个正则表达式其实变成：/abc{0}/
 /abc??/ => 第1个问号是限定符，表示c{0,1}，然后限定符后边出现?表示非贪婪匹配，所以整个正则表达式其实变成： /abc{0}/
```



练习题
1. 筛选出后缀名是.js或.jsx或.json的字符串
如：
原来数组["home.js","data.json","index.css"]
👇
筛选后的数组：["home.js","data.json"]
=========
如果可以，请利用**正则的知识**封装成一个函数，可以循环，函数功能：判断该文件后缀是否有效，如果有效返回true，否则返回false

2个形参：文件名，符合文件后缀的数组
如：
fn("home.js", [".js",".jsx",".json"]) ==> 返回true
fn("home.css", [".js",".jsx",".json"]) ==> 返回false